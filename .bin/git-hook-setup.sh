#!/bin/bash
#
# git-hook-setup.sh - Install git hooks for the monorepo
#
# Usage:
#   .bin/git-hook-setup.sh              # Install all hooks
#   .bin/git-hook-setup.sh --remove     # Remove all hooks
#   .bin/git-hook-setup.sh --strict     # Install with strict secret scanning
#   .bin/git-hook-setup.sh --no-secrets # Install without secret scanning
#   .bin/git-hook-setup.sh --no-lint    # Install without Python linting
#
# Hooks installed:
#   - pre-commit:
#       1. Secret scanning (blocks real secrets, warns on mock secrets)
#       2. Updates COMMIT file with parent hash
#       3. Checks packages_py/ sync with pyproject.toml
#       4. Python linting (ruff + py_compile on staged .py files)
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
HOOKS_DIR="$ROOT_DIR/.git/hooks"

# Options
STRICT_MODE=false
ENABLE_SECRETS=true
ENABLE_PYTHON_LINT=true

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

install_hooks() {
    log_info "Installing git hooks..."

    # Ensure hooks directory exists
    mkdir -p "$HOOKS_DIR"

    # Build secret scanner options
    SECRET_SCANNER_OPTS="--staged"
    if [ "$STRICT_MODE" = true ]; then
        SECRET_SCANNER_OPTS="$SECRET_SCANNER_OPTS --strict"
    fi

    # Create pre-commit hook
    cat > "$HOOKS_DIR/pre-commit" << 'HOOK_HEADER'
#!/bin/bash
#
# Pre-commit hook: Multiple checks
#
# 1. Secret scanning (blocks real secrets, warns on mock secrets)
# 2. Update COMMIT file with parent (HEAD) commit hash
# 3. Ensure packages_py/ changes are reflected in pyproject.toml
#
# Generated by: .bin/git-hook-setup.sh
# To bypass (not recommended): git commit --no-verify
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(dirname "$(dirname "$SCRIPT_DIR")")"

# Initialize pyenv if available (needed for ruff)
# Try multiple locations for GitHub Desktop compatibility
USER_HOME="${HOME:-$(eval echo ~$(whoami))}"
for pyenv_dir in "$USER_HOME/.pyenv" "$PYENV_ROOT"; do
    if [ -d "$pyenv_dir" ]; then
        export PYENV_ROOT="$pyenv_dir"
        export PATH="$PYENV_ROOT/bin:$PYENV_ROOT/shims:$PATH"
        break
    fi
done

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

HOOK_HEADER

    # Add secret scanning section conditionally
    if [ "$ENABLE_SECRETS" = true ]; then
        cat >> "$HOOKS_DIR/pre-commit" << HOOK_SECRETS
# =============================================================================
# STEP 1: Secret Scanning
# =============================================================================
# Scans staged files for secrets, API keys, and tokens before commit.
# - Real secrets: Always block commit
# - Mock/example secrets: Warn (or block in strict mode)

SECRET_SCANNER="\$ROOT_DIR/.bin/scan-secrets.sh"
SECRET_SCANNER_OPTS="$SECRET_SCANNER_OPTS"

if [[ -f "\$SECRET_SCANNER" ]]; then
    # Make scanner executable if needed
    [[ ! -x "\$SECRET_SCANNER" ]] && chmod +x "\$SECRET_SCANNER"

    echo ""
    echo -e "\${GREEN}[pre-commit]\${NC} Scanning for secrets..."

    if ! "\$SECRET_SCANNER" \$SECRET_SCANNER_OPTS; then
        exit_code=\$?
        echo ""
        echo -e "\${RED}=========================================="
        echo "COMMIT BLOCKED: Secrets detected!"
        echo "==========================================${NC}"
        echo ""
        echo "Options:"
        echo "  1. Remove the detected secrets and try again"
        echo "  2. Add false positives to .secrets-allowlist"
        echo "  3. View details: .bin/scan-secrets.sh --staged"
        echo "  4. Interactive: .bin/scan-secrets.sh --staged --fix"
        echo "  5. Bypass (NOT recommended): git commit --no-verify"
        echo ""
        exit \$exit_code
    fi
else
    echo -e "\${YELLOW}[pre-commit]\${NC} Warning: Secret scanner not found, skipping"
fi

HOOK_SECRETS
    fi

    # Add the rest of the hook
    cat >> "$HOOKS_DIR/pre-commit" << 'HOOK_BODY'
# =============================================================================
# STEP 2: Update COMMIT file with parent hash
# =============================================================================
# This updates the COMMIT file with the current HEAD hash (which becomes the
# parent of the new commit). The COMMIT file is auto-staged.
# Location: common/config/COMMIT (alongside YAML config files)

COMMIT_FILE="${ROOT_DIR}/common/config/COMMIT"

# Get current HEAD hash (this will be the parent of the new commit)
PARENT_HASH="$(git rev-parse HEAD 2>/dev/null || echo 'initial')"

# Check if COMMIT file exists and has the current hash
UPDATE_COMMIT=true
if [ -f "${COMMIT_FILE}" ]; then
    EXISTING_HASH="$(cat "${COMMIT_FILE}" | tr -d '[:space:]')"
    if [ "${EXISTING_HASH}" = "${PARENT_HASH}" ]; then
        UPDATE_COMMIT=false
    fi
fi

if [ "$UPDATE_COMMIT" = true ]; then
    echo "${PARENT_HASH}" > "${COMMIT_FILE}"
    git add "${COMMIT_FILE}"
    echo -e "${GREEN}[pre-commit]${NC} Updated COMMIT file with parent hash: ${PARENT_HASH:0:8}"
fi

# =============================================================================
# STEP 3: Check packages_py/ sync with pyproject.toml
# =============================================================================

SYNC_SCRIPT="$ROOT_DIR/.bin/pyproject-sync-pkg-repo.py"
if [[ ! -f "$SYNC_SCRIPT" ]]; then
    echo -e "${YELLOW}[pre-commit]${NC} Warning: .bin/pyproject-sync-pkg-repo.py not found, skipping package sync"
    exit 0
fi

# Check if any packages_py files are staged
if git diff --cached --name-only | grep -q "^packages_py/"; then
    echo -e "${GREEN}[pre-commit]${NC} Detected changes in packages_py/, checking pyproject.toml sync..."

    # Run sync in dry-run mode to check
    OUTPUT=$(python3 "$SYNC_SCRIPT" --dry-run 2>&1)

    if echo "$OUTPUT" | grep -q "DRY RUN:"; then
        echo ""
        echo -e "${RED}=========================================="
        echo "pyproject.toml needs to be updated!"
        echo "==========================================${NC}"
        echo ""
        echo "Run the following command to sync:"
        echo "  python .bin/pyproject-sync-pkg-repo.py"
        echo ""
        echo "Then add the changes:"
        echo "  git add pyproject.toml"
        echo ""
        exit 1
    fi
fi

HOOK_BODY

    # Add Python linting section conditionally
    if [ "$ENABLE_PYTHON_LINT" = true ]; then
        cat >> "$HOOKS_DIR/pre-commit" << 'HOOK_PYTHON_LINT'
# =============================================================================
# STEP 4: Python Linting (staged .py files only)
# =============================================================================
# Runs ruff linter and py_compile on staged Python files.
# Only checks files in packages_py/ that are part of this commit.

PYTHON_LINTER="$ROOT_DIR/.bin/python-linting.py"

# Get staged Python files in packages_py/
STAGED_PY_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep "^packages_py/.*\.py$" | grep -v "__pycache__" | grep -v "\.venv" || true)

if [[ -n "$STAGED_PY_FILES" ]]; then
    echo ""
    echo -e "${GREEN}[pre-commit]${NC} Linting staged Python files..."

    if [[ -f "$PYTHON_LINTER" ]]; then
        # Create temp directory for staged files
        LINT_FAILED=false

        # Check each staged file with ruff
        for py_file in $STAGED_PY_FILES; do
            if [[ -f "$py_file" ]]; then
                # Syntax check
                if ! python3 -m py_compile "$py_file" 2>/dev/null; then
                    echo -e "${RED}[pre-commit]${NC} Syntax error in: $py_file"
                    LINT_FAILED=true
                fi
            fi
        done

        # Run ruff on all staged Python files (if any exist)
        EXISTING_FILES=""
        for py_file in $STAGED_PY_FILES; do
            if [[ -f "$py_file" ]]; then
                EXISTING_FILES="$EXISTING_FILES $py_file"
            fi
        done

        if [[ -n "$EXISTING_FILES" ]]; then
            # Find ruff: use direct path to avoid pyenv shim issues
            RUFF_CMD=""
            USER_HOME="\${HOME:-\$(eval echo ~\$(whoami))}"
            for ruff_path in "\$USER_HOME/.pyenv/versions/3.11.0/bin/ruff" "\$USER_HOME/.pyenv/versions/3.12.0/bin/ruff" "\$USER_HOME/.local/bin/ruff"; do
                if [[ -x "\$ruff_path" ]]; then
                    RUFF_CMD="\$ruff_path"
                    break
                fi
            done
            if [[ -z "\$RUFF_CMD" ]]; then
                RUFF_CMD="ruff"  # fallback to PATH
            fi
            RUFF_OUTPUT=$($RUFF_CMD check --ignore E501,F401,F811,F403,E402 $EXISTING_FILES 2>&1 || true)
            if [[ -n "$RUFF_OUTPUT" ]] && ! echo "$RUFF_OUTPUT" | grep -q "All checks passed"; then
                echo ""
                echo -e "${RED}[pre-commit]${NC} Ruff linting errors found:"
                echo "$RUFF_OUTPUT" | head -20
                if [[ $(echo "$RUFF_OUTPUT" | wc -l) -gt 20 ]]; then
                    echo "  ... (truncated, run 'ruff check' for full output)"
                fi
                LINT_FAILED=true
            fi
        fi

        if [ "$LINT_FAILED" = true ]; then
            echo ""
            echo -e "${RED}=========================================="
            echo "COMMIT BLOCKED: Python linting errors!"
            echo "==========================================${NC}"
            echo ""
            echo "Options:"
            echo "  1. Fix the linting errors and try again"
            echo "  2. Auto-fix: python3 .bin/python-linting.py --fix"
            echo "  3. Check all: python3 .bin/python-linting.py"
            echo "  4. Bypass (NOT recommended): git commit --no-verify"
            echo ""
            exit 1
        fi

        echo -e "${GREEN}[pre-commit]${NC} Python linting passed ($(echo $STAGED_PY_FILES | wc -w | tr -d ' ') files)"
    else
        echo -e "${YELLOW}[pre-commit]${NC} Warning: Python linter not found, skipping"
    fi
fi

HOOK_PYTHON_LINT
    fi

    # Add final success message
    cat >> "$HOOKS_DIR/pre-commit" << 'HOOK_FOOTER'
echo -e "${GREEN}[pre-commit]${NC} All checks passed!"
exit 0
HOOK_FOOTER

    chmod +x "$HOOKS_DIR/pre-commit"
    log_info "Installed pre-commit hook"

    # Remove old hooks if they exist (from previous versions)
    for old_hook in pre-push post-commit; do
        if [ -f "$HOOKS_DIR/$old_hook" ]; then
            rm "$HOOKS_DIR/$old_hook"
            log_info "Removed old $old_hook hook"
        fi
    done

    log_info "Git hooks installed successfully!"
    echo ""
    echo "Installed hooks:"
    echo "  - pre-commit:"
    if [ "$ENABLE_SECRETS" = true ]; then
        if [ "$STRICT_MODE" = true ]; then
            echo "      1. Secret scanning (STRICT: blocks real AND mock secrets)"
        else
            echo "      1. Secret scanning (blocks real secrets, warns on mock)"
        fi
    else
        echo "      1. Secret scanning: DISABLED"
    fi
    echo "      2. Updates COMMIT file with parent hash (auto-staged)"
    echo "      3. Checks packages_py/ sync with pyproject.toml"
    if [ "$ENABLE_PYTHON_LINT" = true ]; then
        echo "      4. Python linting (ruff + py_compile on staged .py files)"
    else
        echo "      4. Python linting: DISABLED"
    fi
    echo ""
    echo "To test secret scanner:  .bin/scan-secrets.sh --staged"
    echo "To test Python linting:  python3 .bin/python-linting.py"
    echo "To reinstall hooks:      .bin/git-hook-setup.sh"
}

remove_hooks() {
    log_info "Removing git hooks..."

    if [[ -f "$HOOKS_DIR/pre-commit" ]]; then
        rm "$HOOKS_DIR/pre-commit"
        log_info "Removed pre-commit hook"
    else
        log_warn "pre-commit hook not found"
    fi

    log_info "Git hooks removed successfully!"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --remove|-r)
            remove_hooks
            exit 0
            ;;
        --strict)
            STRICT_MODE=true
            shift
            ;;
        --no-secrets)
            ENABLE_SECRETS=false
            shift
            ;;
        --no-lint)
            ENABLE_PYTHON_LINT=false
            shift
            ;;
        --help|-h)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --remove, -r   Remove installed hooks"
            echo "  --strict       Enable strict mode (block mock secrets too)"
            echo "  --no-secrets   Disable secret scanning"
            echo "  --no-lint      Disable Python linting"
            echo "  --help, -h     Show this help message"
            echo ""
            echo "Examples:"
            echo "  $0                # Install with all checks enabled"
            echo "  $0 --strict       # Install with strict secret scanning"
            echo "  $0 --no-secrets   # Install without secret scanning"
            echo "  $0 --no-lint      # Install without Python linting"
            echo "  $0 --remove       # Uninstall hooks"
            echo ""
            echo "Secret Scanner:"
            echo "  Test:        .bin/scan-secrets.sh --staged"
            echo "  Full scan:   .bin/scan-secrets.sh --all"
            echo "  Interactive: .bin/scan-secrets.sh --staged --fix"
            echo ""
            echo "Python Linter:"
            echo "  Test:        python3 .bin/python-linting.py"
            echo "  Auto-fix:    python3 .bin/python-linting.py --fix"
            echo "  Verbose:     python3 .bin/python-linting.py -v"
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Default action: install hooks
install_hooks
